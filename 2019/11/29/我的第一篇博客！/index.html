<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>我的第一篇博客！ | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="* 1.类似integer与int类型的转换需要注意值的大小（-128-127）,超过则会new对象。 * 2.类存泄露：被分配的对象可达，有引用指向，但无用。不会被GC回收。 * 2.短路||如果左边为true则不会对右边进行判断，短路&amp;amp;&amp;amp;如果左边为假则不会对右边进行判断。 * 4.String str &#x3D; new String(&amp;quot;hello&amp;quot;); * 上面的">
<meta property="og:type" content="article">
<meta property="og:title" content="我的第一篇博客！">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;29&#x2F;%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%81&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="* 1.类似integer与int类型的转换需要注意值的大小（-128-127）,超过则会new对象。 * 2.类存泄露：被分配的对象可达，有引用指向，但无用。不会被GC回收。 * 2.短路||如果左边为true则不会对右边进行判断，短路&amp;amp;&amp;amp;如果左边为假则不会对右边进行判断。 * 4.String str &#x3D; new String(&amp;quot;hello&amp;quot;); * 上面的">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-11-28T21:30:13.133Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-我的第一篇博客！" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%81/" class="article-date">
  <time datetime="2019-11-28T21:27:32.000Z" itemprop="datePublished">2019-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      我的第一篇博客！
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>* 1.类似integer与int类型的转换需要注意值的大小（-128-127）,超过则会new对象。
* 2.类存泄露：被分配的对象可达，有引用指向，但无用。不会被GC回收。
* 2.短路||如果左边为true则不会对右边进行判断，短路&amp;&amp;如果左边为假则不会对右边进行判断。
* 4.String str = new String(&quot;hello&quot;);
* 上面的语句中变量str放在栈上，用new创建出来的字符串对象放在堆上，而&quot;hello&quot;这个字面量是放在方法区的。
* 5.JAVA数组只有length属性，string有length（），在js中string通过length得到。
* 6.在调用”ab”.intern()方法的时候会返回”ab”，但是这个方法会首先检查字符串池中是否有”ab”这个字符串，7.如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串池中，然会返回这个字符串的引用。
* 8.String s = new String(&quot;xyz&quot;);创建了几个字符串对象？
* 答：两个对象，一个是静态区的&quot;xyz&quot;，一个是用new创建在堆上的对象。
* 9.当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。
* (hashmap,hashtable,set,list,分布式事务，dubbo，垃圾回收机制，6种设计原则【开闭原则，里氏替换原则，单一职责原则，依赖倒置原则，迪米特法则，接口隔离原则】，)
* 10.为什么hashmap的key和value都能存储null值：
*  hash方法中明确指出当key值为null时返回hash值为0，并不会报错，且putVal方法中也没有对value值进行任何约束，故HashMap中的键值都能存放null值。而hashtable的value为null时会直接抛出空指针异常，key会调用hashcode方法，所以同样也会报空指针异常。
* 11：编译是将你写的代码弄成Java虚拟机可以执行的字节码。
* 运行是Java虚拟机运行你写的代码(编译后的字节码文件)，然后显示运行结果。
* Java代码是为了编程方便，而Java虚拟机是不能直接执行Java代码的，所以要把Java代码编译，也就是生成.class文件，然后再由Java虚拟机运行字节码文件，结果才是你写的程序。</code></pre><p>1、什么是延迟加载    * 延迟加载的条件：resultMap可以实现高级映射（使用association、collection实现一对一及一对多映射），association、collection具备延迟加载功能。<br>    * 延迟加载的好处：先从单表查询、需要时再从关联表去关联查询，大大提高 数据库性能，因为查询单表要比关联查询多张表速度要快。<br>    *<br>延迟加载的实例：如果查询订单并且关联查询用户信息。如果先查询订单信息即可满足要求，当我们需要查询用户信息时再查询用户信息。把对用户信息的按需去查询就是延迟加载。<br>    * rabbitmq如何做持久化： 做法是可以先从 Connection 对象中拿到一个 Channel 信道对象，然后再可以通过该对象设置 消息持久化。<br>    * 线程周期的五种状态：新建状态，就绪，运行，等待（等待状态wait（），同步阻塞，其它阻塞sleep（），join（））），死亡。<br>    * 对象的创建过程：类加载检查–&gt;分配内存–&gt;初始化零值–&gt;设置对象头–&gt;执行init方法 <a href="https://blog.csdn.net/dachengxi/article/details/53432853" target="_blank" rel="noopener">https://blog.csdn.net/dachengxi/article/details/53432853</a><br>    * 四大域和九大内置对象：(request,session,severletcontext,pagecontext)(request,response,session,application,config,exception,page,out,pagecontext)<br>    * 什么是跨域问题:如何解决跨域的:指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。所谓同源是指，域名，协议，端口均相同，只要有一个不同，就是跨域。nginx 转发( 代理的方式 ),JSONP 方式( 添加响应头，允许跨域 ),spring拦截器解决跨域问题<br>    * 事务的传播行为：<br>    * |PROPAGATION_REQUIRED | 支持当前事务，假设当前没有事务。就新建一个事务 |<br>    * | PROPAGATION_SUPPORTS |支持当前事务，假设当前没有事务，就以非事务方式运行 |<br>    * | PROPAGATION_MANDATORY| 支持当前事务，假设当前没有事务，就抛出异常|<br>    * | PROPAGATION_REQUIRES_NEW | 新建事务，假设当前存在事务。把当前事务挂起|<br>    * |PROPAGATION_NOT_SUPPORTED | 以非事务方式运行操作。假设当前存在事务，就把当前事务挂起 |<br>    * | PROPAGATION_NEVER | 以非事务方式运行，假设当前存在事务，则抛出异常 |<br>    * | PROPAGATION_NESTED |如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。<br>    *<br>    * 动态SQL标签、#{}和$区别：${ } 变量的替换阶段是在动态 SQL 解析阶段，而 #{ }变量的替换是在 DBMS 中<br>    * hibernate二级缓存： 第二级缓存是进程范围或者集群范围的缓存。第二级对象有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。第二级缓存是可选的，可以在每个类或每个集合的粒度上配置第二级缓存。<br>    * Mysql优化（1、表结构优化   2、SQL语句优化  3，从数据库配置方面进行优化）： 1.数字类型：非万不得已不要使用DOUBLE，  字符类型：非万不得已不要使用 TEXT 数据类型，， .时间类型：尽量使用TIMESTAMP类型，因为其存储空间只需要 DATETIME 类型的一半， ENUM &amp; SET：对于状态字段，可以尝试使用 ENUM 来存放，因为可以极大的降低存储空间，， 五、尽量使用 NOT NULL，（ innodb_buffer_pool_size（缓冲池相关））<br>    * 数据库引擎：innodb,memory,csv,myisam<br>    * cas:CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。　　<br>    * mysql:乐观锁：提交更新时判断数据库中对应记录的当前时间戳是否与之前取出来的时间戳一致，一致就更新，不一致就重试。<br>    * jvm主要包括四个部分：类加载器，执行引擎，内存区，（堆，方法区，本地方法栈，虚拟机栈，程序计数器），本地方法接口<br>    * 方法区(Method Area)：用于存储类结构信息的地方，包括常量池、静态变量、构造函数等。虽然JVM规范把方法区描述为堆的一个逻辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。<br>    * java堆(Heap)：存储java实例或者对象的地方。这块是GC的主要区域（后面解释）。从存储的内容我们可以很容易知道，方法区和堆是被所有java线程共享的。<br>    * java栈(Stack)：java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈、方法返回值等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在java栈中入栈到出栈的过程。所以java栈是现成私有的。<br>    * 程序计数器(PC Register)：用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。<br>    * 本地方法栈(Native Method Stack)：和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。<br>    * I/O多路复用：<br>    * 此模型用到select和poll函数，这两个函数也会使进程阻塞，select先阻塞，有活动套接字才返回，但是和阻塞I/O不同的是，这两个函数可以同时阻塞多个I/O操作，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写（就是监听多个socket）。select被调用后，进程会被阻塞，内核监视所有select负责的socket，当有任何一个socket的数据准备好了，select就会返回套接字可读，我们就可以调用recvfrom处理数据。正因为阻塞I/O只能阻塞一个I/O操作，而I/O复用模型能够阻塞多个I/O操作，所以才叫做多路复用。<br>    * 创建一个类的实例都有那些方法：（1）用new 语句创建对象，这是最常用的创建对象方法。（2）运用反射手段，调用Java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。（3）调用对象的clone()方法（4）运用反序列化手段，调java.io.ObjectInputStream对象的readObject()方法<br>    * .Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；<br>    * 什么是死锁以及避免死锁： 线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行，产生条件：1.互斥条件， 2.请求和保持条件， 3.不剥夺条件， 4.循环等待条件，避免死锁：加锁顺序，加锁时限，死锁检测。<br>    * 线程和进程的差别是什么？：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位<br>    * ConcurrentHashMap 使用锁分段技术，将数据分成一段一段的存储，给每一段数据配置一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其它线程访问<br>    * Entry是Map中用来保存一个键值对的，而Map实际上就是多个Entry的集合。Entry&lt;key,value&gt;和Map&lt;key,value&gt;一样的理解方式就OK了<br>    * 类似autowired的注解：resource，inject；<br>    * 可逆：rsa,不可逆：md5,shal<br>    * 查看mysql数据库索引： SELECT * FROM mysql.<code>innodb_index_stats</code> a WHERE a.<code>database_name</code> = ‘数据库名’ and a.table_name like ‘%表名%’<br>    * mybatis批量操作：foreach <foreach collection="list" item="item" open="(" close=")" separator="," index="index"> #{item.xx}, #{item.xx} </foreach><br>    * http与https的区别：①https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用②http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。③http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。<br>    * springboot内置容器：tomcat，jetty，undertow<br>    * spring bean作用域：singleton,request,session,prototype,globalsession,<br>    * 一般跨进程通信有：AIDL、Message、ContentProvider、Socket这些方式<br>    * springboot解决跨域问题：ngnix跨域配置，配置filter， 编写一个支持跨域请求的 Configuration， 在前端需要访问的Controller的映射方法前加@CrossOrigin注解标记   原理：  res.addHeader(“Access-Control-Allow-Origin”,origin)。<br>    * dubbo工作原理：service,config,register,proxy,cluster(集群层),moniter（监控层）,protocol（远程调用层）,exchange（信息交换层）,transport（网络传输层）,serialize,<br>    * 默认就是走dubbo协议的，单一长连接，NIO异步通信，基于hessian作为序列化协议<br>    * Dubbo提供的集群容错模式：<br>    * Failover Cluster：失败重试<br>    * 当服务消费方调用服务提供者失败后自动切换到其他服务提供者服务器进行重试。这通常用于读操作或者具有幂等的写操作，需要注意的是重试会带来更长延迟。可通过 retries=”2” 来设置重试次数（不含第一次）。<br>    * Failfast Cluster：快速失败<br>    * 当服务消费方调用服务提供者失败后，立即报错，也就是只调用一次。通常这种模式用于非幂等性的写操作。<br>    * Failsafe Cluster：失败安全<br>    * 当服务消费者调用服务出现异常时，直接忽略异常。这种模式通常用于写入审计日志等操作。<br>    * Failback Cluster：失败自动恢复<br>    * 当服务消费端用服务出现异常后，在后台记录失败的请求，并按照一定的策略后期再进行重试。这种模式通常用于消息通知操作。<br>    * Forking Cluster：并行调用<br>    * 当消费方调用一个接口方法后，Dubbo Client会并行调用多个服务提供者的服务，只要一个成功即返回。这种模式通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。<br>    * Broadcast Cluster：广播调用<br>    * 当消费者调用一个接口方法后，Dubbo Client会逐个调用所有服务提供者，任意一台调用异常则这次调用就标志失败。这种模式通常用于通知所有提供者更新缓存或日志等本地资源信息。<br>    * Dubbo的负载均衡策略：<br>    * hash一致性，随机，轮训，最近最少使用<br>    * dubbo动态代理策略<br>    *  默认使用javassist动态字节码生成，创建代理类<br>    * spi，简单来说，就是 service provider interface，说白了是什么意思呢，比如你有个接口，现在这个接口有 3 个实现类，那么在系统运行的时候对这个接口到底选择哪个实现类呢？这就需要 spi 了，需要根据指定的配置或者是默认的配置，去找到对应的实现类加载进来，然后用这个实现类的实例对象。<br>    * 如何基于 Dubbo 进行服务治理、服务降级、失败重试以及超时重试？<br>    *  调用链路自动生成， 服务访问压力以及时长统计， • 服务分层，（避免循环依赖），调用链路失败监控和报警服务鉴权，每个服务的可用性的监控<br>    * zookeeper使用场景： 分布式协调， 分布式锁<br>    * redis分布式锁和zk分布式锁的对比<br>    * redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能<br>    * zk分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小<br>    * </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%81/" data-id="ck3j8ivj30001xkv528nw7lrd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/11/29/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/29/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%81/">我的第一篇博客！</a>
          </li>
        
          <li>
            <a href="/2019/11/29/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>